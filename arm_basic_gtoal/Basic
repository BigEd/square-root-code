        AREA    |BASIC$$Code|, CODE, READONLY, PIC

;> Basic
 ORG &8000
RELEASE * 1;1 for release version: no MANDEL or Roger
RRX * 0;1 for 2 micron ARM use
NOHELP * 1;1 for no help messages
 ^ 0
WRITEC # 1
WRITES # 1
WRITE0 # 1
NEWLINE # 1
READC # 1
CLI # 1
BYTE # 1
WORD # 1
FILE # 1
ARGS # 1
BGET # 1
BPUT # 1
MULTIPLE # 1
OPEN # 1
READLINE # 1
CONTROL # 1
GETENV # 1
EXIT # 1
SETENV # 1
INTON # 1
INTOFF # 1
CALLBACK # 1
ENTERSWI # 1
BREAKPT # 1
BREAKCT # 1
UNUSEDSWI # 1
SETMEMC # 1
SETCALLBACK # 1
MOUSE # 1 ;<-
WRITEI * 256
;allocation of the data pointer itself
VARS * &18000
;allocation relative to vars/ARGP
 ^ 0
PROCPTR # 4
VARPTR # 4*("z"+1-"A") ;arranged s.t. 4*(ch-"@") is right
RECPTR # 4
FNPTR # 4
INTVAR # 4*27
ASSPC * 4*("P"-"@")+INTVAR
PAGE # 4; &160
TOP # 4
LOMEM # 4
HIMEM # 4
FSA # 4
DATAP # 4
TALLY # 4
WIDTHLOC # 4
FREELIST # 256; &17C (one word for sizes 4..252(3,4,5) bytes)
ERRNUM # 4
ERRORH # 4
ERRSTK # 4
ERRLIN # 4 ;&294
ESCWORD # 4
ESCFLG * ESCWORD
TRCFLG * ESCWORD+1
TRCNUM # 4
TIMEOF # 4 ;time offset - initially 0
LOCALARLIST # 4
INSTALLLIST # 4
LIBRARYLIST # 4
MEMLIMIT # 4 ;&2A8

CALLEDNAME # &300-7-(MEMLIMIT+4)
SEED # 5
LISTOP # 1
BYTESM # 1

STRACC # 256
OUTPUT # 512
ERRORS # 256
FREE # 0 ;start of everything else
;GOSUB.RETURN is TRETURN, ADDR
;REPEAT.UNTIL is TUNTIL, ADDR
;WHILE.ENDWHILE is TENDWH, block start ADDR, expr start ADDR
;integer FOR.NEXT is TNEXT, varaddr, ADDR, step, limit
;fp FOR.NEXT is TFOR, varaddr, ADDR, step (8), limit (8)
;FN is n words on stack, the bottom being TFN
;PROC is n words on stack, the bottom being TPROC
;LOCAL A(X) is (, linklist, address, numbytes, arraylist
R0 RN 0
R1 RN 1
R2 RN 2
R3 RN 3
R4 RN 4
R5 RN 5
R6 RN 6
R7 RN 7
R8 RN 8
R9 RN 9
R10 RN 10
R11 RN 11
R12 RN 12
R13 RN 13
R14 RN 14
R15 RN 15
PC RN R15
CFLAG * &20000000
 B MAIN
FACC RN R0
FACCX RN R1
FGRD RN R2
CLEN RN R2 ;acutually contains STRACC+CLEN
FSIGN RN R3
FWACC RN R4
FWACCX RN R5
FWGRD RN R6
FWSIGN RN R7
ARGP RN R8
TYPE RN R9
AELINE RN R11
LINE RN R12
SP RN R13
SOURCE RN R1
DEST RN R2
MODE RN R3
CONSTA RN R4 ;0 for none, tconst for allowed
SMODE RN R5

TINTEGER * &40000000 ;string TYPE is 0
TFP * &80000000

;pull and junk n items from stack
 MACRO
$L PULLJ $N
$L ADD SP,SP,#4*$N
 MEND
;allow space for n items from stack
 MACRO
$L PUSHJ $N
$L SUB SP,SP,#4*$N
 MEND
;load misaligned word using 2 other registers $DEST MUST BE < $W2
;$DEST may be $ADDR
 MACRO
$L LOAD $DEST,$ADDR,$W1,$W2
$L BIC $W2,$ADDR,#3
 AND $W1,$ADDR,#3
 LDMIA $W2,{$DEST,$W2}
 MOVS $W1,$W1,LSL #3
 MOVNE $DEST,$DEST,LSR $W1
 RSBNE $W1,$W1,#32
 ORRNE $DEST,$DEST,$W2,LSL $W1
 MEND
OSESCR MOV R11,R11,LSL #1
 AND R11,R11,#&80
 MOV R12,#VARS
 STRB R11,[R12,#ESCFLG]
 MOV PC,R14
OSERRR MOV R14,#VARS
 ADD R14,R14,#STRACC
 ADD R14,R14,#4
 B MSGERR
MYNAME = "ARW!"
MAIN MOV ARGP,#VARS
 ADR R0,OSERRR
 ADD R1,ARGP,#STRACC
 ADR R2,OSESCR
 MOV R3,#0
 SWI CONTROL
 ADD R0,ARGP,#FREE ;lomem
 STR R0,[ARGP,#PAGE]
 SWI GETENV
 MOV SP,R1 ;get himem limit
 STR SP,[ARGP,#HIMEM]
 STR SP,[ARGP,#MEMLIMIT]
 MOV R0,#0
 STR R0,[ARGP,#ERRLIN]
 STR R0,[ARGP,#TIMEOF]
 STR R0,[ARGP,#ESCWORD]
 STR R0,[ARGP,#LOCALARLIST]
 STR R0,[ARGP,#INSTALLLIST]
 STRB R0,[ARGP,#LISTOP]
 STRB R0,[ARGP,#ERRNUM]
 MVN R0,#0
 STR R0,[ARGP,#WIDTHLOC]
 MOV R0,#10
 ORR R0,R0,#&900
 STR R0,[ARGP,#INTVAR] ;set @%
 LDR R0,[ARGP,#SEED]
 LDRB R1,[ARGP,#SEED+4]
 ORRS R0,R0,R1,LSL #31 ;gets bottom bit
 LDREQ R0,MYNAME
 STREQ R0,[ARGP,#SEED]
 SWI WRITES
REPSTR = "ARM"
 [ RRX=1
 = "2"
 ]
 [ RELEASE=0
 = " BBC Basic V version -1 (C) Roger 1987",10,13,0
 SWI WRITES
 = " a ",0
 BL PATOUT
 = &3F,&61,&D1,&BF,&B0,&B9,&B6,&E2
 = &00,&80,&80,&3C,&47,&C6,&CE,&78
 = &00,&00,&1E,&33,&73,&3F,&03,&06
 = &00,&1E,&33,&3E,&F8,&0F,&00,&00
 = &01,&07,&0C,&38,&E0,&80,&00,&00
 = &C0,&60,&20,&00,&00,&00,&00,&00
 SWI WRITES
 = "prog",10,13,10,13,0
 ALIGN
 |
 = " BBC Basic V version 1.00 (C) Acorn 1987",10,13,10,13,0
 ]
 ADR R0,REPSTR
 ADD R2,ARGP,#ERRORS
ENTRYL LDRB R1,[R0],#1
 STRB R1,[R2],#1
 TEQ R1,#0
 BNE ENTRYL
 STR R1,[ARGP,#ESCWORD]
 BL FROMAT
 BL SETFSA
 BL ORDERR
 ADD LINE,ARGP,#STRACC
 LDR SP,[ARGP,#HIMEM]
 MOV R0,#0
;to stop pops getting carried away
 STMFD SP!,{R0-R9}
 STR SP,[ARGP,#ERRSTK]
;see if there's a name waiting to be read in
 SWI GETENV
 ADD R3,ARGP,#CALLEDNAME
ENTRE1 LDRB R2,[R0],#1
 STRB R2,[R3],#1
 TEQ R2,#0
 BEQ CLRSTK
 CMP R2,#" "
 BHI ENTRE1
 MOV R2,#0
 STRB R2,[R3,#-1]
ENTRE2 LDRB R2,[R0],#1
 CMP R2,#" "
 BEQ ENTRE2
 MOV R9,#2 ;set to chain
 CMP R2,#"-"
 BEQ ENTRYKEYW
ENTRYCONT TEQ R2,#0
 BEQ CLRSTK
 TEQ R2,#"@"
 BNE ENTRYF
 MOV R9,#0 ;no chain
 BL RDHEX ;incore text file
 MOV R6,R5
 TEQ R2,#","
 BNE CLRSTK
 BL RDHEX
 TEQ R2,#0
 BNE CLRSTK
 CMP R5,R6
 BLS CLRSTK
 MOV R1,R6
ENTRY0 MOV R4,#9
ENTRY1 STMFD SP!,{R4,R5}
 BL MATCH
 LDMFD SP!,{R4}
 STMFD SP!,{R1}
 ADD LINE,ARGP,#OUTPUT
 BL SPTSTN
 BEQ ENTRYINSIMPL
 ORR R9,R9,#1 ;needs renumber
 ADD LINE,ARGP,#OUTPUT
 BL INSERT ;put at current end of text with current line number
 B ENTRYINDONE
ENTRYINSIMPL MOV R4,R0
 BL INSRT
ENTRYINDONE LDMFD SP!,{R1,R5}
 CMP R1,R5
 BCC ENTRY1
ENTRYFINAL TST R9,#1
 BEQ ENTRYFINAL1
 MOV R4,#10
 MOV R5,#10
 BL VSTRNG
 = "Program renumbered",10,13,0
 BL RENUM1
ENTRYFINAL1 TST R9,#2
 BEQ FSASET
 B RUNNER
ENTRYKEYW BL RDCOMCH
 CMP R2,#"H"
 BEQ ENTRYKEYW2
 CMP R2,#"L"
 BEQ ENTRYKEYW3
 CMP R2,#"Q"
 BEQ ENTRYKEYW4
 CMP R2,#"C"
 BL RDCOMCHER
 CMP R2,#"H"
 BL RDCOMCHER
 CMP R2,#"A"
 BL RDCOMCHER
 CMP R2,#"I"
 BL RDCOMCHER
 CMP R2,#"N"
 BL RDCOMCHER
 CMP R2,#" "
 BNE ENTRYUNK
ENTRYCHAIN CMP R2,#" "
 BNE ENTRYCONT
 LDRB R2,[R0],#1
 B ENTRYCHAIN
ENTRYKEYW4 BL RDCOMCH
 CMP R2,#"U"
 BL RDCOMCH
 CMP R2,#"I"
 BL RDCOMCH
 CMP R2,#"T"
 BL RDCOMCH
 CMP R2,#" "
 BNE ENTRYUNK
 MOV R1,#0
 STRB R1,[ARGP,#CALLEDNAME]
 B ENTRYCHAIN
ENTRYKEYW3 BL RDCOMCH
 CMP R2,#"O"
 BL RDCOMCH
 CMP R2,#"A"
 BL RDCOMCH
 CMP R2,#"D"
 BL RDCOMCH
 CMP R2,#" "
 BNE ENTRYUNK
 MOV R9,#0
 B ENTRYCHAIN
ENTRYKEYW2 BL RDCOMCH
 CMP R2,#"E"
 BL RDCOMCH
 CMP R2,#"L"
 BL RDCOMCH
 CMP R2,#"P"
 BL RDCOMCH
 BL VSTRNG
 = "ab -help activated (use HELP at the > prompt for more help):",10,13,0
 B ENTRYHELP
ENTRYUNK BL VSTRNG
 = "Unknown keyword.",10,13,0
ENTRYHELP BL VSTRNG
 = "ab [-chain] <filename> to run a file (text/tokenised).",10,13
 = "ab -quit <filename> to run a file (text/tokenised) and quit when done.",10,13
 = "ab -load <filename> to start with a file (text/tokenised).",10,13
 = "ab @xxxxxxxx,xxxxxxxx to start with in-core text.",10,13,0
 B FSASET
ENTRYF ADD R4,ARGP,#STRACC
ENTRF1 STRB R2,[R4],#1
 LDRB R2,[R0],#1
 CMP R2,#" "
 BHI ENTRF1
 MOV R5,#13
 STRB R5,[R4],#1
 MOV R0,#&FF
 ADD R1,ARGP,#STRACC
 LDR R7,[ARGP,#PAGE]
 ADD R7,R7,#4096
 MOV R2,R7
 MOV R3,#0
 SWI FILE
 MOV R1,R7 ;start
 ADD R5,R1,R4 ;finish
ENTRYFCHK LDRB R6,[R7]
 TEQ R6,#13
 BNE ENTRY0
 LDRB R6,[R7,#1]
 CMP R6,#&FF
 BEQ ENTRYFENC
 LDRB R6,[R7,#3]
 CMP R6,#4
 BCC ENTRY0
 ADD R7,R7,R6
 B ENTRYFCHK
ENTRYFENC LDR R0,[ARGP,#PAGE]
ENTRYFCOPY LDR R7,[R1],#4
 STR R7,[R0],#4
 CMP R1,R5
 BCC ENTRYFCOPY
 BL ENDER
 B ENTRYFINAL
RDHEX MOV R5,#0
 MOV R4,#32-4
RDHEX1 LDRB R2,[R0],#1
 CMP R2,#"0"
 BCC CLRSTK
 CMP R2,#"9"+1
 BCC RDHEX2
 CMP R2,#"A"
 BCC CLRSTK
 CMP R2,#"F"+1
 BCS CLRSTK
 SUB R2,R2,#"A"-"9"-1
RDHEX2 AND R2,R2,#&F
 ORR R5,R5,R2,LSL R4
 SUBS R4,R4,#4
 BPL RDHEX1
 LDRB R2,[R0],#1
 MOV PC,R14
RDCOMCHER BNE ENTRYUNK
RDCOMCH LDRB R2,[R0],#1
 CMP R2,#"a"
 BICCS R2,R2,#" "
 MOV PC,R14
NEW BL DONES
 BL FROMAT
FSASET BL SETFSA
CLRSTK MOV ARGP,#VARS
 ADD LINE,ARGP,#STRACC
 LDR R0,[ARGP,#HIMEM]
 BL POPLOCALAR
 LDR SP,[ARGP,#HIMEM]
 MOV R0,#0
 STMFD SP!,{R0-R9} ;to stop pops getting carried away
 MVN R0,#0
 STRB R0,[ARGP,#BYTESM]
 STR SP,[ARGP,#ERRSTK]
 BL ORDERR
CLRSTK1 LDRB R0,[ARGP,#CALLEDNAME]
 CMP R0,#0
 SWIEQ EXIT
 SWI WRITEI+">"
 BL INLINE ;R1=STRACC
 BL SETVAR
 BL MATCH
 ADD LINE,ARGP,#OUTPUT
 STMFD SP!,{SMODE}
 BL SPTSTN
 LDMFD SP!,{SMODE}
 BNE DC
 STMFD SP!,{SMODE}
 MOV R4,R0
 BL INSRT
 LDMFD SP!,{SMODE}
 CMP SMODE,#&1000
 BCC WARNC
 SWI WRITES
 = "Warning: unmatched ()",10,13,0
 ALIGN
WARNC TST SMODE,#256
 BEQ WARNQ
 SWI WRITES
 = "Warning: line number too big",10,13,0
 ALIGN
WARNQ AND SMODE,SMODE,#255
 TEQ SMODE,#1
 BNE FSASET
 SWI WRITES
 = "Warning: unmatched """,10,13,0
 ALIGN
 B FSASET
DOSTAR MOV R0,LINE ;do oscli
 BL OSCLIREGS
 SWI CLI
DATA
DEF
REM LDRB R10,[LINE],#1
ENDEDL CMP R10,#13
 BNE REM
CRLINE LDRB R10,[LINE],#1
 CMP R10,#&FF
 BEQ CLRSTK ;check for program end
 ADD LINE,LINE,#2
 LDR R4,[ARGP,#ESCWORD] ;check for exceptional conditions
 CMP R4,#0
 BEQ STMT ;nothing exceptional
 BL DOEXCEPTION
 B STMT
ENDIF
ENDCA
DONXTS LDRB R10,[LINE],#1
DONEXT CMP R10,#" "
 BEQ DONXTS
 CMP R10,#":"
 BEQ STMT
 CMP R10,#13
 BEQ CRLINE
 CMP R10,#TELSE
 BNE ERSYNT
 B REM
GOTLT2 CMP R10,#"-"
 TEQCC R10,#"+"
 BNE MISTAK
 LDRB R10,[AELINE],#1
 TEQ R10,#"="
 BNE MISTAK
 BCC PLUSBC
MINUSBC CMP TYPE,#256+128
 BCS ERTYPEARRAYB
 BL EXPR
 TEQ TYPE,#0
 BEQ ERTYPEINT
 RSBPL FACC,FACC,#0
 BPL PLUSBC1
 TEQ FACC,#0
 EORNE FSIGN,FSIGN,#&80000000
 B PLUSBC1
PLUSBC BL EXPR
PLUSBC1 BL AEDONE
 LDMFD SP,{R4,R5}
 CMP R5,#5
 BEQ PLUSBCFP
 BCS PLUSBCSTRING
 BL INTEGY
 MOV R4,FACC
 LDMFD SP,{FACC,TYPE}
 BL VARIND
 ADD FACC,FACC,R4
 BL STORE
 B NXT
PLUSBCSTRING CMP R5,#256
 BCS ARRAYPLUSBC
 TEQ TYPE,#0
 BNE ERTYPESTR
 MOV R7,SP
 BL SPUSH
 LDMFD R7,{FACC,TYPE}
 BL VARIND
 LDMFD SP!,{R7}
 ADD R6,ARGP,#STRACC
 SUBS R7,R7,R6
 BEQ PLUSBCSX
 ADD R6,R7,CLEN
 SUB R6,R6,ARGP
 CMP R6,#256+STRACC
 BCS ERLONG
PLUSBCLP LDRB R6,[SP],#1
 STRB R6,[CLEN],#1
 SUBS R7,R7,#1
 BNE PLUSBCLP
 ADD SP,SP,#3
 BIC SP,SP,#3
PLUSBCSX BL STORE
 B NXT
PLUSBCFP BL FLOATY
 BL FTOW
 LDMFD SP!,{TYPE,AELINE}
 BL F1LDA
 BL FADDW
 BL F1STA
 B NXT
DC MOV R3,#255
 STRB R3,[R2] ;limit end of immmediate mode line
 CMP R10,#TESCCOM
 BNE DISPAT
 LDRB R10,[LINE],#1
 SUBS R4,R10,#&8E
 LDR R4,[PC,R4,LSL #2]
 ADD PC,PC,R4
AJ2 * .+4
 & APPEND-AJ2
 & AUTO-AJ2
 & DELETE-AJ2
 & EDIT-AJ2
 & HELP-AJ2
 & LIST-AJ2
 & LOAD-AJ2
 & LVAR-AJ2
 & NEW-AJ2
 & OLD-AJ2
 & RENUM-AJ2
 & SAVE-AJ2
 & TWIN-AJ2
 & TWINO-AJ2
LETST MOV AELINE,LINE
 BL LVCONT
 BNE GOTLT
 BCS DONEXT
 MOV R0,AELINE
LETST1 LDRB R7,[R0],#1
 CMP R7,#" "
 BEQ LETST1
 CMP R7,#"="
 BNE MISTAK
 BL CREATE
GOTLT STMFD SP!,{FACC,TYPE}
GOTLT1 LDRB R10,[AELINE],#1
 CMP R10,#" "
 BEQ GOTLT1
 CMP R10,#"="
 BNE GOTLT2
 CMP TYPE,#256
 BCS LETARRAY
 BL EXPR
 MOV LINE,AELINE
 CMP R10,#":"
 CMPNE R10,#13
 CMPNE R10,#TELSE
 BNE ERSYNT
 BL STORE
NXT CMP R10,#":"
 BNE ENDEDL
STMT LDRB R10,[LINE],#1
 CMP R10,#" "
 BEQ STMT
;go to value of token in R10, using r4
DISPAT LDR R4,[PC,R10,LSL #2]
 ADD PC,PC,R4
AJ * .+4
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & CRLINE-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & STMT-AJ
 & LETST-AJ
 & ERSYNT-AJ
 & ERSYNT-AJ
 & LETST-AJ; 24
 & LETST-AJ; 25
 & LETST-AJ; 26
 & LETST-AJ; 27
 & LETST-AJ; 28
 & LETST-AJ; 29
 & DOSTAR-AJ
 & LETST-AJ; 2B
 & LETST-AJ; 2C
 & LETST-AJ; 2D
 & LETST-AJ; 2E
 & LETST-AJ; 2F
 & LETST-AJ; 30
 & LETST-AJ; 31
 & LETST-AJ; 32
 & LETST-AJ; 33
 & LETST-AJ; 34
 & LETST-AJ; 35
 & LETST-AJ; 36
 & LETST-AJ; 37
 & LETST-AJ; 38
 & LETST-AJ; 39
 & STMT-AJ
 & LETST-AJ; 3B
 & LETST-AJ; 3C
 & FNRET-AJ
 & LETST-AJ; 3E
 & LETST-AJ; 3F
 & LETST-AJ; 40
 & LETST-AJ; 41
 & LETST-AJ; 42
 & LETST-AJ; 43
 & LETST-AJ; 44
 & LETST-AJ; 45
 & LETST-AJ; 46
 & LETST-AJ; 47
 & LETST-AJ; 48
 & LETST-AJ; 49
 & LETST-AJ; 4A
 & LETST-AJ; 4B
 & LETST-AJ; 4C
 & LETST-AJ; 4D
 & LETST-AJ; 4E
 & LETST-AJ; 4F
 & LETST-AJ; 50
 & LETST-AJ; 51
 & LETST-AJ; 52
 & LETST-AJ; 53
 & LETST-AJ; 54
 & LETST-AJ; 55
 & LETST-AJ; 56
 & LETST-AJ; 57
 & LETST-AJ; 58
 & LETST-AJ; 59
 & LETST-AJ; 5A
 & ASS-AJ; 5B
 & LETST-AJ; 5C
 & LETST-AJ; 5D
 & LETST-AJ; 5E
 & LETST-AJ; 5F
 & LETST-AJ; 60
 & LETST-AJ; 61
 & LETST-AJ; 62
 & LETST-AJ; 63
 & LETST-AJ; 64
 & LETST-AJ; 65
 & LETST-AJ; 66
 & LETST-AJ; 67
 & LETST-AJ; 68
 & LETST-AJ; 69
 & LETST-AJ; 6A
 & LETST-AJ; 6B
 & LETST-AJ; 6C
 & LETST-AJ; 6D
 & LETST-AJ; 6E
 & LETST-AJ; 6F
 & LETST-AJ; 70
 & LETST-AJ; 71
 & LETST-AJ; 72
 & LETST-AJ; 73
 & LETST-AJ; 74
 & LETST-AJ; 75
 & LETST-AJ; 76
 & LETST-AJ; 77
 & LETST-AJ; 78
 & LETST-AJ; 79
 & LETST-AJ; 7A
 & ERSYNT-AJ
 & LETST-AJ; |
 & ERSYNT-AJ
 & ERSYNT-AJ
 & OTHER-AJ
 & ERSYNT-AJ; AND
 & ERSYNT-AJ; DIV
 & ERSYNT-AJ; EOR
 & ERSYNT-AJ; MOD
 & ERSYNT-AJ; OR
 & LERROR-AJ
 & LINEST-AJ
 & CURSOFF-AJ
 & ERSYNT-AJ; STEP
 & ERSYNT-AJ; SPC
 & ERSYNT-AJ; TAB
 & REM-AJ; ELSE
 & ERSYNT-AJ; THEN
 & ERSYNT-AJ; 8D
 & ERSYNT-AJ; OPENU

 & LPTR-AJ
 & LPAGE-AJ
 & LTIME-AJ
 & LLOMEM-AJ
 & LHIMEM-AJ

 & ERSYNT-AJ; ABS
 & ERSYNT-AJ; ACS
 & ERSYNT-AJ; ADC
 & ERSYNT-AJ; ASC
 & ERSYNT-AJ; ASN
 & ERSYNT-AJ; ATN
 & ERSYNT-AJ; BBGET
 & ERSYNT-AJ; COS
 & ERSYNT-AJ; COUNT
 & ERSYNT-AJ; DEG
 & ERSYNT-AJ; ERL
 & ERSYNT-AJ; ERR
 & ERSYNT-AJ; EVAL
 & ERSYNT-AJ; EXP
 & LEXT-AJ; EXT
 & ERSYNT-AJ; FALSE
 & ERSYNT-AJ; FN
 & ERSYNT-AJ; GET
 & ERSYNT-AJ; INKEY
 & ERSYNT-AJ; INSTR
 & ERSYNT-AJ; INT
 & ERSYNT-AJ; LEN
 & ERSYNT-AJ; LN
 & ERSYNT-AJ; LOG
 & ERSYNT-AJ; NOT
 & ERSYNT-AJ; OPENI
 & ERSYNT-AJ; OPENO
 & ERSYNT-AJ; PI
 & ERSYNT-AJ; POINT
 & ERSYNT-AJ; POS
 & ERSYNT-AJ; RAD
 & ERSYNT-AJ; RND
 & ERSYNT-AJ; SGN
 & ERSYNT-AJ; SIN
 & ERSYNT-AJ; SQR
 & ERSYNT-AJ; TAN
 & ERSYNT-AJ; TO
 & ERSYNT-AJ; TRUE
 & ERSYNT-AJ; USR
 & ERSYNT-AJ; VAL
 & ERSYNT-AJ; VPOS
 & ERSYNT-AJ; CHRD
 & ERSYNT-AJ; GETD
 & ERSYNT-AJ; INKED
 & LLEFTD-AJ
 & LMIDD-AJ
 & LRIGHTD-AJ
 & ERSYNT-AJ; STRD
 & ERSYNT-AJ; STRND
 & ERSYNT-AJ; EOF

 & ERSYNT-AJ ;functions disallowed
 & ERSYNT-AJ ;commands disallowed
 & TWOSTMT-AJ ;two byte statements

 & WHEN-AJ
 & ERSYNT-AJ ;OF
 & ENDCA-AJ
 & ELSE2-AJ
 & ENDIF-AJ
 & ENDWH-AJ
 & LPTR-AJ
 & LPAGE-AJ
 & LTIME-AJ
 & LLOMEM-AJ
 & LHIMEM-AJ
 & SOUND-AJ
 & BBPUT-AJ
 & CALL-AJ
 & CHAIN-AJ
 & CLEAR-AJ
 & CLOSE-AJ
 & CLG-AJ
 & CLS-AJ
 & DATA-AJ
 & DEF-AJ
 & DIM-AJ
 & DRAW-AJ
 & END-AJ
 & ENDPR-AJ
 & ENVEL-AJ
 & FOR-AJ
 & GOSUB-AJ
 & GOTO-AJ
 & GCOL-AJ
 & IF-AJ
 & INPUT-AJ
 & LET-AJ
 & LOCAL-AJ
 & MODES-AJ
 & MOVE-AJ
 & NEXT-AJ
 & ON-AJ
 & VDU-AJ
 & PLOT-AJ
 & PRINT-AJ
 & PROC-AJ
 & READ-AJ
 & REM-AJ
 & REPEAT-AJ
 & REPORT-AJ
 & RESTORE-AJ
 & RETURN-AJ
 & RUN-AJ
 & STOP-AJ
 & COLOUR-AJ
 & TRACE-AJ
 & UNTIL-AJ
 & WIDTH-AJ
 & OSCL-AJ
TWOSTMT LDRB R10,[LINE],#1
 SUBS R4,R10,#&8E
 LDR R4,[PC,R4,LSL #2]
 ADD PC,PC,R4
AJ3 * .+4
 & CASE-AJ3
 & CIRCLE-AJ3
 & FILL-AJ3
 & ORGIN-AJ3
 & PSET-AJ3
 & RECT-AJ3
 & SWAP-AJ3
 & WHILE-AJ3
 & WAIT-AJ3
 & DOMOUSE-AJ3
 & QUIT-AJ3
 & SYS-AJ3
 & INSTALL-AJ3
 & LIBRARY-AJ3
 & DOTINT-AJ3
 [ RELEASE=1
 & ERSYNT-AJ3
 |
 & MANDEL-AJ3
 ]

;clear text
FROMAT MOV R0,#13
 LDR R1,[ARGP,#PAGE]
 STRB R0,[R1],#1
 MOV R0,#&FF
 STRB R0,[R1],#1 ;post index to get value for TOP
 STR R1,[ARGP,#TOP]
 MOV R0,#0
 STR R0,[ARGP,#TRCNUM]
 MOV PC,R14
SETFSA LDR R0,[ARGP,#TOP]
 ADD R0,R0,#3
 BIC R0,R0,#3
 STR R0,[ARGP,#LOMEM]
 STR R0,[ARGP,#FSA]
 MOV R6,#0
 ADD R1,ARGP,#FREELIST
 ADD R2,R1,#256
SETFREEL STR R6,[R1],#4
 CMP R1,R2
 BCC SETFREEL
 MOV R6,R14 ;save return address
 BL SETVAR
 MOV R14,R6
SETVAL ADD R1,ARGP,#PROCPTR
 ADD R2,R1,#(FNPTR+4-PROCPTR)
 MOV R0,#0
 STR R0,[ARGP,#LIBRARYLIST]
SETVRL STR R0,[R1],#4
 TEQ R1,R2
 BNE SETVRL
 MOV PC,R14
SETVAR LDR R0,[ARGP,#PAGE]
 STR R0,[ARGP,#DATAP]
 MOV PC,R14
MSG BIC R0,R14,#&FC000000 ;byte error from inside AB's tables
 ADD R1,ARGP,#STRACC
 MOV R14,R1
 LDRB R2,[R0],#1
 STR R2,[R1],#4
MSGBYTE LDRB R2,[R0],#1
 STRB R2,[R1],#1
 CMP R2,#0
 BNE MSGBYTE
MSGERR MOV ARGP,#VARS ;cardinal error from outside world
 MOV R0,#&D0
 MOV R1,#0
 MOV R2,#0
 SWI BYTE
 MOV R0,#&7E
 SWI BYTE
 MOV R0,#0
 STRB R0,[ARGP,#TRCFLG] ;disable any tracing
 SUB LINE,LINE,#2 ;seems a good idea
 LDR R1,[ARGP,#PAGE]
MSG0 CMP R1,LINE
 BHI MSG1
 LDRB R2,[R1,#1]
 CMP R2,#&FF
 BEQ MSG1
 LDRB R0,[R1,#2]
 ADD R0,R0,R2,LSL #8
 LDRB R2,[R1,#3]
 ADD R1,R1,R2
 B MSG0
MSG1 STR R0,[ARGP,#ERRLIN]
 ADD R1,ARGP,#ERRORS
 ADR LINE,ERRHAN
 LDR R0,[R14],#4
 STR R0,[ARGP,#ERRNUM]
 TEQ R0,#0
 LDRNE LINE,[ARGP,#ERRORH]
 STREQ LINE,[ARGP,#ERRORH]
MSGA LDRB R0,[R14],#1
 STRB R0,[R1],#1
 TEQ R0,#0
 BNE MSGA
 BL SETVAR
 LDR R0,[ARGP,#ERRSTK]
 BL POPLOCALAR
 LDR SP,[ARGP,#ERRSTK]
 B STMT
INLINE ADD R0,ARGP,#STRACC
 MOV R1,#238
 MOV R2,#" "
 MOV R3,#255
 SWI READLINE
 BCS ESCAPE
 ADD R1,ARGP,#STRACC
 B CTALLY
NLINE SWI NEWLINE
CTALLY MOV R2,#0
 STR R2,[ARGP,#TALLY]
 MOV PC,R14
ORDERR ADR R0,ERRHAN
 STR R0,[ARGP,#ERRORH]
 MOV PC,R14
ERRHAN = "!(",THIMEM,"-4)=@%:@%=&900:",TREPORT,":",TIF,TERL
 = TPRINT,""" at line """,TERL,TELSE,TPRINT,13,0,0,0
 = "@%=!(",THIMEM,"-4):",TEND,13
 ALIGN
;remove from line number in r4 to line number in r5
REMOVE MOV R0,R4
 STMFD SP!,{R14}
 BL FNDLNO
 MOV R6,R1
 ADD R0,R5,#1 ;next line plus one
 BL FNDLNONEXT ;continue from where we are now
 CMP R1,R6
 LDMLSFD SP!,{PC} ;very easy
 LDR R0,[ARGP,#TOP]
REMOVL LDRB R2,[R1],#1 ;pick up a byte from high up
 STRB R2,[R6],#1 ;put it low down
 CMP R1,R0
 BNE REMOVL
 STR R6,[ARGP,#TOP]
 LDMFD SP!,{PC}
INSERT STMFD SP!,{R14} ;insert at end of text
 LDR R1,[ARGP,#TOP]
 SUB R1,R1,#2 ;address of cr
 B INSRTS
;insert the line whose number is in R4, whose first char is ptd to by LINE
INSRT STMFD SP!,{R14}
 MOV R5,R4
 BL REMOVE
 LDRB R0,[LINE]
 CMP R0,#13
 LDMEQFD SP!,{PC}
 MOV R0,R4
 BL FNDLNO ;get position to R1
 LDRB R0,[ARGP,#LISTOP]
 TEQ R0,#0
 BEQ INSRTS
 BL SPACES
 SUB LINE,LINE,#1
INSRTS MOV AELINE,LINE
LENGTH LDRB R0,[AELINE],#1
 CMP R0,#13
 BNE LENGTH
 SUB AELINE,AELINE,#1
TRALSP LDRB R0,[AELINE,#-1]!
 CMP AELINE,LINE
 BLS TRALEX
 CMP R0,#" "
 BEQ TRALSP
TRALEX MOV R0,#13
 STRB R0,[AELINE,#1]!
 SUB R6,AELINE,LINE ;raw length 0..n
 ADD R6,R6,#4 ;length as desired
 CMP R6,#256
 BCS ERLINELONG
 LDR R2,[ARGP,#TOP]
 ADD R3,R2,R6 ;calc new TOP
 STR R3,[ARGP,#TOP]
MOVEUP LDRB R0,[R2,#-1]!
 STRB R0,[R3,#-1]!
 TEQ R2,R1
 BNE MOVEUP
 STRB R4,[R1,#2]
 MOV R5,R4,LSR #8
 STRB R5,[R1,#1] ;lo and hi bytes of line number
 STRB R6,[R1,#3]! ;length
INSLP1 LDRB R0,[LINE],#1
 STRB R0,[R1,#1]!
 CMP R0,#" "
 BEQ INSLP1
 TEQ R0,#13
 LDMEQFD SP!,{PC}
 TEQ R0,#TELSE
 MOVEQ R0,#TELSE2
 STREQB R0,[R1]
INSLP2 LDRB R0,[LINE],#1
 STRB R0,[R1,#1]!
 TEQ R0,#13
 BNE INSLP2
 LDMFD SP!,{PC}

;routine which prints string following calling instruction and returns
VSTRNG BIC R0,R14,#&FC000003 ;remove superfluous bits
 SWI WRITE0
 ADD R0,R0,#3
 BIC PC,R0,#3
 [ RELEASE=0
PATOUT BIC R2,R14,#&FC000003
 BL PATA
 BL PATA
 BL PATA
 BL PATA
 BL PATA
 BL PATA
 SWI WRITEI+23
 SWI WRITEI+" "
 MOV R14,R2
 ]
FLUSH8 SWI WRITEI+0
FLUSH7 SWI WRITEI+0
 SWI WRITEI+0
 SWI WRITEI+0
 SWI WRITEI+0
 SWI WRITEI+0
 SWI WRITEI+0
 SWI WRITEI+0
 MOV PC,R14
PATA LDR R0,[R2],#4
 SWI WRITEI+23
 SWI WRITEI+" "
 SWI WRITEC
 MOV R0,R0,ROR #8
 SWI WRITEC
 MOV R0,R0,ROR #8
 SWI WRITEC
 MOV R0,R0,ROR #8
 SWI WRITEC
 LDR R0,[R2],#4
 SWI WRITEC
 MOV R0,R0,ROR #8
 SWI WRITEC
 MOV R0,R0,ROR #8
 SWI WRITEC
 MOV R0,R0,ROR #8
 SWI WRITEC
 SWI WRITEI+" "
 MOV PC,R14

 ^ &7F ;single byte tokens
TOTHER # 1
TAND # 1 ;expression binary operators
TDIV # 1
TEOR # 1
TMOD # 1
TOR # 1

TERROR # 1  ;miscellaneous words
TLINE # 1
TOFF # 1
TSTEP # 1
TSPC # 1
TTAB # 1
TELSE # 1
TTHEN # 1

TCONST # 1   ;(8D)

TOPENU # 1

TPTR # 1 ;polymorphics as functions
TPAGE # 1
TTIME # 1
TLOMEM # 1
THIMEM # 1
TABS # 1 ;expression class of unary operators
TACS # 1
TADC # 1
TASC # 1
TASN # 1
TATN # 1
TBGET # 1
TCOS # 1
TCOUNT # 1
TDEG # 1
TERL # 1
TERR # 1
TEVAL # 1
TEXP # 1
TEXT # 1
TFALSE # 1
TFN # 1
TGET # 1
TINKEY # 1
TINSTR # 1
TINT # 1
TLEN # 1
TLN # 1
TLOG # 1
TNOT # 1
TOPENI # 1
TOPENO # 1
TPI # 1
TPOINT # 1
TPOS # 1
TRAD # 1
TRND # 1
TSGN # 1
TSIN # 1
TSQR # 1
TTAN # 1
TTO # 1
TTRUE # 1
TUSR # 1
TVAL # 1
TVPOS # 1
TCHRD # 1  ;string expression class of unary operators
TGETD # 1
TINKED # 1
TLEFTD # 1
TMIDD # 1
TRIGHTD # 1
TSTRD # 1
TSTRND # 1
TEOF # 1

TESCFN # 1 ;Escape for Functions
TESCCOM # 1 ;Escape for Commands
TESCSTMT # 1 ;Escape for Statements

TWHEN # 1 ;statements
TOF # 1
TENDCA # 1
TELSE2 # 1
TENDIF # 1
TENDWH # 1

TPTR2 # 1 ;polymorphic again
TPAGE2 # 1
TTIME2 # 1
TLOMM2 # 1
THIMM2 # 1

TBEEP # 1
TBPUT # 1
TCALL # 1
TCHAIN # 1
TCLEAR # 1
TCLOSE # 1
TCLG # 1
TCLS # 1
TDATA # 1
TDEF # 1
TDIM # 1
TDRAW # 1
TEND # 1
TENDPR # 1
TENVEL # 1
TFOR # 1
TGOSUB # 1
TGOTO # 1
TGRAPH # 1
TIF # 1
TINPUT # 1
TLET # 1
TLOCAL # 1
TMODE # 1
TMOVE # 1
TNEXT # 1
TON # 1
TVDU # 1
TPLOT # 1
TPRINT # 1
TPROC # 1
TREAD # 1
TREM # 1
TREPEAT # 1
TREPORT # 1
TRESTORE # 1
TRETURN # 1
TRUN # 1
TSTOP # 1
TTEXT # 1
TTRACE # 1
TUNTIL # 1
TWIDTH # 1
TOSCL # 1 ;this must be <=&FF (!)

 ^ &8E ;Two byte function tokens
TSUM # 1

 ^ &8E ;Two byte Statement tokens
TCASE # 1
TCIRCLE # 1
TFILL # 1
TORGIN # 1
TPSET # 1
TRECT # 1
TSWAP # 1
TWHILE # 1
TWAIT # 1
TMOUSE # 1
TQUIT # 1
TSYS # 1
TINSTALL # 1
TLIBRARY # 1
TTINT # 1
 [ RELEASE=0
TMANDEL # 1
 ]

 ^ &8E ;Two byte Command tokens
TAPPEND # 1
TAUTO # 1
TDELET # 1
TEDIT # 1
THELP # 1
TLIST # 1
TLOAD # 1
TLVAR # 1
TNEW # 1
TOLD # 1
TRENUM # 1
TSAVE # 1
TTWIN # 1
TTWINO # 1

 LNK Lexical
