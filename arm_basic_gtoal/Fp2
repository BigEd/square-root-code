; > fp2
COS STMFD SP!,{R14}
 BL FACTOR
 BLPL FLOATQ
 CMP FACCX,#&98
 BCS FRNGQQ
 MOV R10,#0
 MOV FSIGN,#0
 BL FPUSH ;stack |X|
 ADR TYPE,HALFPI
 BL FADD
 BL FRANGE
 BLMI FCLR
 BL INTRND
 TST FACC,#1
 EORNE R10,R10,#&80000000
 BL IFLT
 MOV FWSIGN,#&80000000
 MOV FWACC,#&80000000
 MOV FWACCX,#&80
 BL FADDW
 B SINCOMMON
SIN ROUT
 STMFD SP!,{R14}
 BL FACTOR
 BLPL FLOATQ
 CMP FACCX,#&98
 BCS FRNGQQ
 MOV R10,FSIGN
 MOV FSIGN,#0
 BL FPUSH ;stack |X|
 BL FRANGE
 BLMI FCLR
 BL INTRND
 TST FACC,#1
 EORNE R10,R10,#&80000000
 TEQ FACC,#0
 BEQ %20
 BL IFLT
;
; STMFD SP!,{FACC,FSIGN,FACCX}
; ADR TYPE,HPIHI
; BL FMUL
; ADD TYPE,SP,#3*4+4 ;input value
; BL FADD
; BL FSTA
; LDMFD SP!,{FACC,FSIGN,FACCX}
; ADR TYPE,HPILO
; BL FMUL
; ADD TYPE,SP,#4 ;input value
; BL FADD
;
; Here follows DJS's disgusting code to multiply FACC by pi
;  = (2^0) + (2^-1) + (2^-4) + (2^-7) + (2^-11) - (2^-18) - (2^-20)
;    + (2^-22) + (2^-24) + (2^-26) + (2^-30) + (2^-34) + (2^-38)
;    - (2^-40) - (2^-42) + (2^-44) - (2^-49)
SINCOMMON MOV FGRD,FACC,LSR #2
 ADD FGRD,FGRD,FACC,LSR #6
 SUB FGRD,FGRD,FACC,LSR #8
 SUB FGRD,FGRD,FACC,LSR #10
 ADD FGRD,FGRD,FACC,LSR #12
 SUB FGRD,FGRD,FACC,LSR #17
 MOV FWACC,#0
 ADDS FGRD,FGRD,FACC,LSL #31
 ADC FWACC,FWACC,FACC,LSR #1
 ADDS FGRD,FGRD,FACC,LSL #28
 ADC FWACC,FWACC,FACC,LSR #4
 ADDS FGRD,FGRD,FACC,LSL #25
 ADC FWACC,FWACC,FACC,LSR #7
 ADDS FGRD,FGRD,FACC,LSL #21
 ADC FWACC,FWACC,FACC,LSR #11
 SUBS FGRD,FGRD,FACC,LSL #14
 SBC FWACC,FWACC,FACC,LSR #18
 SUBS FGRD,FGRD,FACC,LSL #12
 SBC FWACC,FWACC,FACC,LSR #20
 ADDS FGRD,FGRD,FACC,LSL #10
 ADC FWACC,FWACC,FACC,LSR #22
 ADDS FGRD,FGRD,FACC,LSL #8
 ADC FWACC,FWACC,FACC,LSR #24
 ADDS FGRD,FGRD,FACC,LSL #6
 ADC FWACC,FWACC,FACC,LSR #26
 ADDS FGRD,FGRD,FACC,LSL #2
 ADC FWACC,FWACC,FACC,LSR #30
 ADDS FACC,FACC,FWACC
 ADDCS FACCX,FACCX,#1 ;Re-normalise
 MOVCS FGRD,FGRD,LSR #1
 ORRCS FGRD,FGRD,FACC,LSL #31
 MOVCS FACC,FACC,RRX
 ADD FACCX,FACCX,#1
;
; No overflow/underflow possible. Rounding not wanted because both
; parts of result are going to be subtracted from value on stack
;
 EOR FSIGN,FSIGN,#&80000000 ;Negate to do subtraction
 MOV TYPE,SP ;input value
 STMFD SP!,{FGRD,FSIGN,FACCX}
 BL FADD
 BL FSTA
 LDMFD SP!,{FGRD,FSIGN,FACCX} ;Recover guard word
 SUB FACCX,FACCX,#32
 MOVS FACC,FGRD
 BEQ %20
10 SUBPL FACCX,FACCX,#1 ;Re-normalise - NB expected to be faster than
 MOVPLS FACC,FACC,LSL #1 ;binary chop method in this environment
 BPL %10
 TEQ FACCX,#0
 BMI %20
 MOV TYPE,SP
 BL FADD ;result of first addition
 BL FSTA
 B %30
20 MOV TYPE,SP
 BL FLDA ;input value
30 CMP FACCX,#&71
 BCC ENDSIN
 BL FSQR
 BL FPUSH ;stack g, f
 ADR TYPE,SINR5
 BL FMUL
 ADR TYPE,SINR4
 BL FADD
 MOV TYPE,SP
 BL FMUL
 ADR TYPE,SINR3
 BL FADD
 MOV TYPE,SP
 BL FMUL
 ADR TYPE,SINR2
 BL FADD
 MOV TYPE,SP
 BL FMUL
 ADR TYPE,SINR1
 BL FADD
 MOV TYPE,SP
 BL FMUL
 ADD SP,SP,#8
 MOV TYPE,SP
 BL FMUL
 BL FADD
ENDSIN ADD SP,SP,#8
 EOR FSIGN,FSIGN,R10
 MOVS TYPE,#TFP
 LDMFD SP!,{PC}
SINR5 DCD &CD070C7F
 = &67,0,0,&80 ;-.2386834640601E-7
SINR4 DCD &B8B5D27E
 = &6E,0,0,0 ;.2752397106775E-5
SINR3 DCD &D00BD47F
 = &74,0,0,&80 ;-.1984083282313E-3
SINR2 DCD &888885BA
 = &7A,0,0,0 ;.8333330720556E-2
SINR1 DCD &AAAAAAA1
 = &7E,0,0,&80 ;-.16666666608836
ATN STMFD SP!,{R14}
 BL FACTOR
 BLPL FLOATQ
 STMFD SP!,{FSIGN} ;stack sign
 MOV FSIGN,#0 ;force +ve
 MOV R10,#0
 CMP FACCX,#&81
 CMPCS FACC,#&80000001
 BCC FATNA
 BL FRECIP
 MOV R10,#2
FATNA CMP FACCX,#&7F ;test if greater than .2679491924
 CMPEQ FACC,#&89000000
 CMPEQ FACC,#&00300000
 CMPEQ FACC,#&0000A200
 CMPEQ FACC,#&000000F5
 BCC FATNB
 BL FPUSH ;stack f
 ADR TYPE,ATNCONST1
 BL FMUL
 MOV FWACC,#&80000000
 MOV FWACCX,#&81
 MOV FWSIGN,#&80000000
 BL FADDW
 BL FPUSH ;stack top, f
 ADD TYPE,SP,#8
 BL FLDA
 ADR TYPE,ATNCONST1
 BL FADD
 MOV TYPE,SP
 BL FXDIV
 ADD SP,SP,#16
 ADD R10,R10,#1
FATNB CMP FACCX,#&71
 BCC FATNC ;very small number
 BL FPUSH ;stack f, sign, link
 BL FSQR
 BL FPUSH ;stack g, f etc.
 ADR TYPE,ATNP1
 BL FMUL
 ADR TYPE,ATNP0
 BL FADD
 MOV TYPE,SP
 BL FMUL
 BL FPUSH ;stack q*P(q), g, f etc.
 ADD TYPE,SP,#8
 BL FLDA
 ADR TYPE,ATNQ1
 BL FADD
 ADD TYPE,SP,#8
 BL FMUL
 ADR TYPE,ATNQ0
 BL FADD
 MOV TYPE,SP
 BL FXDIV
 ADD TYPE,SP,#16
 BL FMUL
 BL FADD
 ADD SP,SP,#24
FATNC CMP R10,#1
 EORHI FSIGN,FSIGN,#&80000000
 BCC FATND
 CMP R10,#2
 ADRLT TYPE,SIXTHPI
 ADREQ TYPE,HALFPI
 ADRHI TYPE,THIRDPI
 BL FADD
FATND LDMFD SP!,{R4,R14}
 CMP R4,#0
 EORNE FSIGN,FSIGN,#&80000000
 TEQ FACC,#0
 MOVEQ FSIGN,#0
 MOVS TYPE,#TFP
 MOV PC,R14
ATNCONST1 DCD &DDB3D743
 = &81,0,0,0 ;SQR3=1.732050807568877
ATNP1 DCD &B853ADF8
 = &80,0,0,&80 ;-.720026848898
ATNP0 DCD &B854A78A
 = &81,0,0,&80 ;-1.44008344874
ATNQ1 DCD &98123BF0
 = &83,0,0,0 ;4.75222584599
ATNQ0 DCD &8A3F7DBF
 = &83,0,0,0 ;4.32025038919
; Here follows DJS's disgusting code to multiply FACC by 1/pi
;  = A2F9836E hex      (exponent 7F)
;  = (2^-1) + (2^-3) + (2^-6) - (2^-8) - (2^-13) + (2^-15) - (2^-17)
;    + (2^-22) - (2^-25) - (2^-28) - (2^-31)
FRANGE MOV FWGRD,FACC,LSL #30
 MOV FWACC,FACC,LSR #2
 ADDS FWGRD,FWGRD,FACC,LSL #27
 ADC FWACC,FWACC,FACC,LSR #5
 SUBS FWGRD,FWGRD,FACC,LSL #25
 SBC FWACC,FWACC,FACC,LSR #7
 SUBS FWGRD,FWGRD,FACC,LSL #20
 SBC FWACC,FWACC,FACC,LSR #12
 ADDS FWGRD,FWGRD,FACC,LSL #18
 ADC FWACC,FWACC,FACC,LSR #14
 SUBS FWGRD,FWGRD,FACC,LSL #16
 SBC FWACC,FWACC,FACC,LSR #16
 ADDS FWGRD,FWGRD,FACC,LSL #11
 ADC FWACC,FWACC,FACC,LSR #21
 SUBS FWGRD,FWGRD,FACC,LSL #8
 SBC FWACC,FWACC,FACC,LSR #24
 SUBS FWGRD,FWGRD,FACC,LSL #5
 SBC FWACC,FWACC,FACC,LSR #27
 SUBS FWGRD,FWGRD,FACC,LSL #2
 SBC FWACC,FWACC,FACC,LSR #30
 ADDS FACC,FACC,FWACC
 SUBCC FACCX,FACCX,#1 ;Adjust exponent or re-normalise
 MOVCS FWGRD,FWGRD,LSR #1
 ORRCS FWGRD,FWGRD,FACC,LSL #31
 MOVCS FACC,FACC,RRX
 CMP FWGRD,#&80000000 ;Round correctly
 BICEQ FACC,FACC,#1
 ADDCSS FACC,FACC,#1
 MOVCS FACC,FACC,RRX
 ADDCS FACCX,FACCX,#1
 SUB FACCX,FACCX,#1
 TEQ FACCX,#0 ;Handle underflow (overflow is impossible)
 MOV PC,R14
;convert fp acc to a string in stracc
;using format given by word in FWACC, returns with TYPE 1 after last char
FMAT RN FWACCX
FDIGS RN FWACC ;(no harm the way currently written)
FPRTDX RN FWSIGN
FPRTWN RN FWGRD
FCONFP TEQ R5,#0
 BNE FCONHX
 MOV FMAT,FWACC,ROR #16
 AND FMAT,FMAT,#255
 MOV FDIGS,FWACC,ROR #8
 AND FDIGS,FDIGS,#255
 CMP FMAT,#3
 MOVCS FMAT,#0 ;if unknown format use 3
 CMP FDIGS,#11
 MOVCS FDIGS,#10 ;if too high number of digs use 10
 TEQ FDIGS,#0
 BNE FCONA
 TEQ FMAT,#2
 MOVNE FDIGS,#10 ;if not in format 2 use 10 digits instead of 0
FCONA MOV FPRTDX,#0
 STMFD SP!,{FDIGS,R14} ;May need fdigs again
 BL FLOATY
 ADD TYPE,ARGP,#STRACC
 CMP FACC,#0
 BNE FPRTA
 TEQ FMAT,#0
 BNE FPRTHH
 MOV FWGRD,#"0"
 STRB FWGRD,[TYPE],#1
 LDMFD SP!,{FWGRD,PC} ;discard fdigs and return
FPRTHH TEQ FMAT,#1
 BEQ FPRTK
 B FPRTZR
FPRTA MOV FGRD,#0
 TEQ FSIGN,#0
 MOVMI FSIGN,#"-"
 STRMIB FSIGN,[TYPE],#1
 MOVMI FSIGN,#0
FPRTC CMP FACCX,#&81
 BCS FPRTD
 BL FTENFX
 SUB FPRTDX,FPRTDX,#1
 B FPRTC
FPRTD CMP FACCX,#&84
 BCC FPRTF
 BNE FPRTE
 CMP FACC,#&A0000000
 BCC FPRTF
FPRTE BL FTENFQ
 ADD FPRTDX,FPRTDX,#1
 B FPRTC
FPRTEE BL FONE
 ADD FPRTDX,FPRTDX,#1
 B FPRTC
FPRTF LDR FDIGS,[SP] ;stacked fdigs
 CMP FMAT,#2
 BNE FPRTFH
 ADCS FDIGS,FDIGS,FPRTDX ;fix up precision
 BMI FPRTZR
 CMP FDIGS,#11 ;how many digits?
 MOVCS FDIGS,#10
 MOVCS FMAT,#0 ;treat as G10 format if unreasonable
FPRTFH STMFD SP!,{FMAT,FPRTDX,FDIGS,FACC,FGRD,FSIGN,FACCX} ;facc stuff closest
 MOV FACC,#&A0000000
 MOV FACCX,#&83
 MOV FGRD,#0
 MOV FSIGN,#0 ;5 to acc
 MOVS FWACCX,FDIGS
 BEQ FPRTGJ
FPRTGG BL FTENFQ
 SUBS FWACCX,FWACCX,#1
 BNE FPRTGG
FPRTGJ LDMFD SP!,{FWACCX,FWSIGN,FWGRD,FWACC} ;since facc stuff was closest
 BL FADDW1
FPRTFF CMP FACCX,#&84
 BLCC FTENFA
 [ RRX=0
 BICCC FACC,FACC,#&80000000
 ]
 BCC FPRTFF ;note that this relies on ftenfa preserving C on exit
 LDMFD SP!,{FDIGS,FPRTDX,FMAT}
 CMP FACC,#&A0000000
 BCS FPRTEE ;see if unnormalised: fix up if so
 CMP FDIGS,#0
 BNE FPRTH
FPRTZR LDR FDIGS,[SP]
 ADD FDIGS,FDIGS,#1
 BL FCLR
 MOV FPRTDX,#0
FPRTH MOV FPRTWN,#1
 TEQ FMAT,#1
 BEQ FPRTK
 TEQ FPRTDX,#0
 BMI FPRTKK
 CMP FPRTDX,FDIGS
 BCS FPRTK
 ADD FPRTWN,FPRTDX,#1
 MOV FPRTDX,#0
 B FPRTK
FPRTKK TEQ FMAT,#2
 BEQ FPRTKL
 CMN FPRTDX,#1
 CMNNE FPRTDX,#2
 BNE FPRTK
FPRTKL MOV FPRTWN,#"."
 STRB FPRTWN,[TYPE,#1] ;store "0." in string (interestingly!)
 MOV FPRTWN,#"0"
 STRB FPRTWN,[TYPE],#2 ;put the zero at the beginning and then skip the .
FPRTKM ADDS FPRTDX,FPRTDX,#1
 STRNEB FPRTWN,[TYPE],#1 ;put in 0 if ne 0
 BNE FPRTKM ;round again
 MOV FPRTWN,#&80
FPRTK MOV FSIGN,FACC,LSR #32-4
 ORR FSIGN,FSIGN,#"0"
 STRB FSIGN,[TYPE],#1
 BIC FACC,FACC,#&F0000000
 BL FTENX
 SUBS FPRTWN,FPRTWN,#1
 MOVEQ FSIGN,#"."
 STREQB FSIGN,[TYPE],#1
 SUBS FDIGS,FDIGS,#1
 BNE FPRTK
 TEQ FMAT,#1
 BEQ FPRTTX
 TEQ FMAT,#2
 BEQ FPRTTY
FPRTTZ LDRB FSIGN,[TYPE,#-1]!
 CMP FSIGN,#"0"
 BEQ FPRTTZ
 CMP FSIGN,#"."
 ADDNE TYPE,TYPE,#1
FPRTTY TEQ FPRTDX,#0
 BEQ FPRTX
FPRTTX MOV FSIGN,#"E"
 STRB FSIGN,[TYPE],#1
 ADDS FPRTWN,FPRTDX,#0
 MOVMI FSIGN,#"-"
 STRMIB FSIGN,[TYPE],#1
 RSBMI FPRTWN,FPRTWN,#0
 MOV FSIGN,#"0"
IPRTA SUBS FPRTWN,FPRTWN,#10
 ADDCS FSIGN,FSIGN,#1
 BCS IPRTA
 TEQ FSIGN,#"0"
 STRNEB FSIGN,[TYPE],#1
 ADD FPRTWN,FPRTWN,#"0"+10
 STRB FPRTWN,[TYPE],#1
 TEQ FMAT,#0
 BEQ FPRTX
 MOV FGRD,#" "
 TEQ FPRTDX,#0
 STRPLB FGRD,[TYPE],#1
 TEQ FSIGN,#"0"
 STREQB FGRD,[TYPE],#1
FPRTX LDMFD SP!,{FDIGS,PC}
;convert to hex string
FCONHX STMFD SP!,{R14}
 BL INTEGY
 ADD TYPE,ARGP,#STRACC
 MOV R2,#32-4
 MOV R3,#0 ;lzb
FCONH1 MOV R1,R0,LSR R2
 AND R1,R1,#15
 CMP R1,#9
 ORRLS R1,R1,#"0"
 ADDHI R1,R1,#"A"-10
 TEQ R2,#0 ;last time?
 MOVEQ R3,#1
 TEQ R3,#0
 CMPEQ R1,#"0"
 MOVNE R3,#1
 STRNEB R1,[TYPE],#1
 SUBS R2,R2,#4
 BPL FCONH1
 LDMFD SP!,{PC}
FRDDXX MOVS TYPE,#TINTEGER ;clear carry: nothing read
 MOV PC,R14
;read constant from aeline: exit with aeline ready for next load of character
FREAD CMP R10,#"."
 MOV FACC,#0
 MOV FGRD,#0
 MOV FSIGN,#0 ;convenient flag for decimal pt
 MOV FWACCX,#0 ;decimal exponent
 BEQ FRDDDD
 SUB R10,R10,#"0"
 CMP R10,#9
 BHI FRDDXX ;if <0 or >9
 MOV FGRD,R10,LSL #24
 LDRB R10,[AELINE],#1
 SUBS FACCX,R10,#"0"
 BCC FRDDDP
 CMP FACCX,#9
 BHI FRDDD
 MOV FACCX,FACCX,LSL #24
 ADD FGRD,FGRD,FGRD,LSL #2
 ADD FGRD,FACCX,FGRD,LSL #1
FRDDC LDRB R10,[AELINE],#1
FRDDDP CMP R10,#"."
 BEQ FRDDDD
FRDDD CMP R10,#"E"
 BEQ FRDDEX ;start of exponent
 SUB R10,R10,#"0"
 CMP R10,#9
 BHI FRDDQ ;end of number
 CMP FACC,#&18000000 ;see how large it is
 TEQ FSIGN,#0 ;both branches need "If after ."
 BCS FRDDE
 SUBNE FWACCX,FWACCX,#1 ;if after "." dec exp
 ADDS FGRD,FGRD,FGRD
 ADC FACC,FACC,FACC
 MOV FACCX,FGRD,LSR #30
 ORR FACCX,FACCX,FACC,LSL #2
 ADDS FGRD,FGRD,FGRD,LSL #2
 ADC FACC,FACC,FACCX
 ADDS FGRD,FGRD,R10,LSL #24
 ADC FACC,FACC,#0
 B FRDDC
FRDDE ADDEQ FWACCX,FWACCX,#1 ;ignore if after "." else increase exponent
 B FRDDC
FRDDDD EORS FSIGN,FSIGN,#1 ;seen "." before ?/set seen now
 BNE FRDDC ;more chars
 EOR FSIGN,FSIGN,#1 ;reset seen
 B FRDDQ ;second one is end of number
FRDDEX MOV FWSIGN,R14
 BL FRDEXP
 MOV R14,FWSIGN
 ADD FWACCX,FWACCX,FWGRD
FRDDQ SUB AELINE,AELINE,#1
 ORRS FACCX,FWACCX,FSIGN
 BEQ FRINT ;no exponent, no decimal so possible integer
FRFP MOV FWSIGN,R14
 ORRS FACCX,FGRD,FACC
 BEQ FRDDZZ
 MOV FACCX,#&A8
 TEQ FACC,#0
 BLPL FNRMA
 TEQ FWACCX,#0
 BEQ FRDDZ
 BMI FRDDM
FRDDP BL FTENFX
 SUBS FWACCX,FWACCX,#1
 BNE FRDDP
 B FRDDZ
FRDDM BL FTENFQ
 ADDS FWACCX,FWACCX,#1
 BNE FRDDM
FRDDZ BL FTIDY
FRDDZZ MOV TYPE,#TFP
 MOV FSIGN,#0
 SUBS TYPE,TYPE,#0 ;set carry and status flags
 MOV PC,FWSIGN ;return
FRINT CMP FACC,#&800000
 BCS FRFP ;too large to represent as integer
 MOV FACC,FACC,LSL #8
 ORR FACC,FACC,FGRD,LSR #32-8
 MOV TYPE,#TINTEGER
 SUBS TYPE,TYPE,#0 ;set carry and status flags
 MOV PC,R14
FRDEXP LDRB R10,[AELINE],#1
 CMP R10,#"-"
 BEQ FRDEXM
 CMP R10,#"+"
 BNE FRDEXA
FRDEXB LDRB R10,[AELINE],#1
FRDEXA CMP R10,#"9"
 BHI FRDEXQ
 SUBS R10,R10,#"0"
 BCC FRDEXQ
 MOV FWGRD,R10
 LDRB R10,[AELINE],#1
 CMP R10,#"9"
 BHI FRDEXX
 SUBS R10,R10,#"0"
 ADDCS AELINE,AELINE,#1
 ADDCS FWGRD,FWGRD,FWGRD,LSL #2
 ADDCS FWGRD,R10,FWGRD,LSL #1
FRDEXX MOV PC,R14
FRDEXQ MOV FWGRD,#0
 MOV PC,R14
FRDEXM STMFD SP!,{R14}
 BL FRDEXB
 RSB FWGRD,FWGRD,#0
 LDMFD SP!,{PC}
 [ 1=0 ;debug code
FSHOW STMFD SP!,{R14,R0,R10,R9}
 SWI WRITES
 = "AA ",0
 MOV R10,FACC
 BL WORDHX
 SWI WRITES
 = " AX ",0
 MOV R10,FACCX
 BL WORDHX
 SWI WRITES
 = " AG ",0
 MOV R10,FGRD
 BL WORDHX
 SWI WRITES
 = " AS ",0
 MOV R10,FSIGN
 BL WORDHX
 SWI NEWLINE
 SWI WRITES
 = "WA ",0
 MOV R10,FWACC
 BL WORDHX
 SWI WRITES
 = " WX ",0
 MOV R10,FWACCX
 BL WORDHX
 SWI WRITES
 = " WG ",0
 MOV R10,FWGRD
 BL WORDHX
 SWI WRITES
 = " WS ",0
 MOV R10,FWSIGN
 BL WORDHX
 SWI NEWLINE
 LDMFD SP!,{R0,R10,R9,PC}^
 ]
WORDSP SWI WRITEI+" "
;print R10
WORDHX STMFD SP!,{R0,R9}
 MOV R9,#32-4
WORDLP MOV R0,R10,LSR R9
 AND R0,R0,#15
 CMP R0,#9
 ORRLS R0,R0,#"0"
 ADDHI R0,R0,#"A"-10
 SWI WRITEC
 SUBS R9,R9,#4
 BPL WORDLP
 LDMFD SP!,{R0,R9}
 MOVS PC,R14
ERSILL BL MSG
 = 0,"Silly!",0
 ALIGN
ERNUMM BL MSG
 = 0,"No room to do this renumber",0
 ALIGN
ERNUMO BL MSG
 = 0,"Line numbers larger than 65279 would be generated by this renumber",0
 ALIGN
ALLOCR BL MSG
 = 0,"No room",0
 ALIGN
ERLINELONG BL MSG
 = 0,"Line too long",0
 ALIGN
ERSTOP BL MSG
 = 0,"Stopped",0
 ALIGN
ERLISTO BL MSG
 = 0,"Invalid LISTO option",0
 ALIGN
ERTWINO BL MSG
 = 0,"Invalid TWINO option",0
 ALIGN
ERCATASLIST MOV R0,#0
 STR R0,[ARGP,#LOCALARLIST]
ERRQ1 BL MSG
 = 0,"Corruption of stack",0
 ALIGN
ONERRX BL MSG
 = 0,"Error control status not found on stack for RESTORE ERROR",0
 ALIGN
BADIC BL MSG
 = 0,"Missing incore name",0
 ALIGN
USESLINENUMBERS BL MSG
 = 0,"LIST/TWIN found line number reference",0
 ALIGN
HELPTOKENNO BL MSG
 = 0,"HELP has no information on this keyword",0
 ALIGN
ERASS1 BL MSG
 = 1,"No such mnemonic",0
 ALIGN
ERASS1EQU BL MSG
 = 1,"No such suffix on EQU",0
 ALIGN
ERASS2 BL MSG
 = 2,"Bad immmediate constant",0
 ALIGN
ERASS2A BL MSG
 = 2,"Bad address offset",0
 ALIGN
ERASS2S BL MSG
 = 2,"Bad shift",0
 ALIGN
ERASS3 BL MSG
 = 3,"Bad register",0
 ALIGN
ERASSMUL BL MSG
 = 3,"Duplicate register in multiply",0
 ALIGN
MISSEQ BL MSG
 = 4,"Missing =",0
 ALIGN
MISSEQFOR BL MSG
 = 4,"Missing = in FOR statement",0
 ALIGN
MISTAK BL MSG
 = 4,"Mistake",0
 ALIGN
ERCOMM BL MSG
 = 5,"Missing ,",0
 ALIGN
ERTYPEINT BL MSG
 = 6,"Type mismatch: number needed",0
 ALIGN
ERTYPENUM BL MSG
 = 6,"Type mismatch: numeric variable needed",0
 ALIGN
ERTYPESTR BL MSG
 = 6,"Type mismatch: string needed",0
 ALIGN
ERTYPESTRING BL MSG
 = 6,"Type mismatch: string variable needed",0
 ALIGN
ERTYPEARRAY BL MSG
 = 6,"Type mismatch: array needed",0
 ALIGN
ERTYPEARRAYB BL MSG
 = 6,"Type mismatch between arrays",0
 ALIGN
ERTYPEARRAYC BL MSG
 = 6,"Can't assign to array of this size",0
 ALIGN
ERSIZE BL MSG
 = 6,"Array type mismatch as parameter",0
 ALIGN
ERTYPESWAP BL MSG
 = 6,"Can't SWAP arrays of diffent types",0
 ALIGN
ERRFN BL MSG
 = 7,"Not in a function",0
 ALIGN
ERDOLL BL MSG
 = 8,"Too low a value for $<number>",0
 ALIGN
ERMISQ BL MSG
 = 9,"Missing """,0
 ALIGN
ERDIMFN BL MSG
 = 10,"DIM() function needs an array",0
 ALIGN
DIMRAM BL MSG
 = 10,"No room for this dimension",0
 ALIGN
ERMATMULSPACE BL MSG
 = 10,"No room to do matrix multiply with source(s) the same as destination",0
 ALIGN
BADDIMSUB BL MSG
 = 10,"Impossible dimension",0
 ALIGN
BADDIMLIST BL MSG
 = 10,"No end of dimension list )",0
 ALIGN
BADDIM BL MSG
 = 10,"Bad DIM statement",0
 ALIGN
BADDIMSIGN BL MSG
 = 10,"Can't DIM negative ammount",0
 ALIGN
BADDIMSIZE BL MSG
 = 10,"No room for this DIM",0
 ALIGN
ERNDIM BL MSG
 = 10,"Arrays cannot be redimensioned",0
 ALIGN
ERRNLC BL MSG
 = 12,"Items can only be made local in a function or procedure",0
 ALIGN
ENDPRE BL MSG
 = 13,"Not in a procedure",0
 ALIGN
ERARRW BL MSG
 = 14,"Reference array incorrect",0
 ALIGN
ERARRY BL MSG
 = 14,"Unknown array",0
 ALIGN
ERARRYDIM BL MSG
 = 14,"Unknown array in DIM() function",0
 ALIGN
ERARRZ BL MSG
 = 14,"Undimensioned array",0
 ALIGN
ERRSUB BL MSG
 = 15,"Subscript out of range",0
 ALIGN
ERRSB2 BL MSG
 = 15,"Incorrect number of subscripts",0
 ALIGN
ERSYNT BL MSG
 = 16,"Syntax error",0
 ALIGN
ESCAPE BL MSG
 = 17,"Escape",0
 ALIGN
ZDIVOR BL MSG
 = 18,"Division by zero",0
 ALIGN
ERLONG BL MSG
 = 19,"String too long",0
 ALIGN
FOVR BL MSG
 = 20,"Number too big",0
 ALIGN
FOVR1 BL MSG
 = 20,"Number too big for arc Sine or arc Cosine",0
 ALIGN
FSQRTN BL MSG
 = 21,"Negative root",0
 ALIGN
ERFLOG BL MSG
 = 22,"Logarithm range",0
 ALIGN
FRNGQQ BL MSG
 = 23,"Accuracy lost in Sine/Cosine/Tangent",0
 ALIGN
ERFEXP BL MSG
 = 24,"Exponent range",0
 ALIGN
FACERR BL MSG
 = 26,"Unknown or missing variable",0
 ALIGN
ERVARAR BL MSG
 = 26,"Can't use array reference here",0
 ALIGN
ERBRA BL MSG
 = 27,"Missing )",0
 ALIGN
ERASSB1 BL MSG
 = 27,"Missing ]",0
 ALIGN
ERASSB2 BL MSG
 = 27,"Missing {",0
 ALIGN
ERASSB3 BL MSG
 = 27,"Missing }",0
 ALIGN
ERHEX BL MSG
 = 28,"Bad Hex",0
 ALIGN
ERHEX2 BL MSG
 = 28,"Hex number too large",0
 ALIGN
ERBIN BL MSG
 = 28,"Bad Binary",0
 ALIGN
FNMISS BL MSG
 = 29,"No such function/procedure",0
 ALIGN
FNCALL BL MSG
 = 30,"Bad call of function/procedure",0
 ALIGN
ARGMAT BL MSG
 = 31,"Arguments of function/procedure incorrect",0
 ALIGN
ARGMATRET BL MSG
 = 31,"Invalid RETURN actual parameter",0
 ALIGN
ARGMATARR BL MSG
 = 31,"Invalid array actual parameter",0
 ALIGN
ERNEXT BL MSG
 = 32,"Not in a FOR loop",0
 ALIGN
NEXTER BL MSG
 = 33,"Can't match FOR",0
 ALIGN
FORCV BL MSG
 = 34,"Bad FOR control variable",0
 ALIGN
FORSTEP BL MSG
 = 35,"The step cannot be zero",0
 ALIGN
FORTO BL MSG
 = 36,"Missing TO",0
 ALIGN
ERGOSB BL MSG
 = 38,"Not in a subroutine",0
 ALIGN
ONER BL MSG
 = 39,"ON syntax",0
 ALIGN
ONRGER BL MSG
 = 40,"ON range",0
 ALIGN
NOLINE BL MSG
 = 41,"No such line",0
 ALIGN
DATAOT BL MSG
 = 42,"Out of data",0
 ALIGN
ERREPT BL MSG
 = 43,"Not in a REPEAT loop",0
 ALIGN
CHANNE BL MSG
 = 45,"Missing #",0
 ALIGN
ERWHIL BL MSG
 = 46,"Not in a WHILE loop",0
 ALIGN
NOENDC BL MSG
 = 47,"Missing ENDCASE",0
 ALIGN
ERCASE1 BL MSG
 = 48,"OF missing from CASE statement",0
 ALIGN
ERCASE BL MSG
 = 48,"CASE..OF statement must be the last thing on a line",0
 ALIGN
NOENDI BL MSG
 = 49,"Missing ENDIF",0
 ALIGN
ERMOUS BL MSG
 = 50,"Bad MOUSE variable",0
 ALIGN
ERSYSINPUTS BL MSG
 = 51,"Too many input expressions for SYS",0
 ALIGN
ERSYSOUTPUTS BL MSG
 = 51,"Too many output variables for SYS",0
 ALIGN
ERINSTALL BL MSG
 = 52,"Can't install library",0
 ALIGN
BADPRO1 BL MSG
 = 52,"Bad program used as function/procedure library",0
 ALIGN
 END
